// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vdom.proto

#ifndef PROTOBUF_vdom_2eproto__INCLUDED
#define PROTOBUF_vdom_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)
#include <list>

namespace vdom {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_vdom_2eproto();
void protobuf_AssignDesc_vdom_2eproto();
void protobuf_ShutdownFile_vdom_2eproto();

class Window;
class Document;
class Node;

enum Node_Type {
  Node_Type_TEXT = 0,
  Node_Type_ELEMENT = 1
};
bool Node_Type_IsValid(int value);
const Node_Type Node_Type_Type_MIN = Node_Type_TEXT;
const Node_Type Node_Type_Type_MAX = Node_Type_ELEMENT;
const int Node_Type_Type_ARRAYSIZE = Node_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Node_Type_descriptor();
inline const ::std::string& Node_Type_Name(Node_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Node_Type_descriptor(), value);
}
inline bool Node_Type_Parse(
    const ::std::string& name, Node_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Node_Type>(
    Node_Type_descriptor(), name, value);
}
enum Node_RenderType {
  Node_RenderType_BLOCK = 0,
  Node_RenderType_INLINE = 1,
  Node_RenderType_IMAGE = 2,
  Node_RenderType_VIDEO = 3,
  Node_RenderType_OTHER = 10
};
bool Node_RenderType_IsValid(int value);
const Node_RenderType Node_RenderType_RenderType_MIN = Node_RenderType_BLOCK;
const Node_RenderType Node_RenderType_RenderType_MAX = Node_RenderType_OTHER;
const int Node_RenderType_RenderType_ARRAYSIZE = Node_RenderType_RenderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Node_RenderType_descriptor();
inline const ::std::string& Node_RenderType_Name(Node_RenderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Node_RenderType_descriptor(), value);
}
inline bool Node_RenderType_Parse(
    const ::std::string& name, Node_RenderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Node_RenderType>(
    Node_RenderType_descriptor(), name, value);
}
// ===================================================================

class Window : public ::google::protobuf::Message {
 public:
  Window();
  virtual ~Window();
  
  Window(const Window& from);
  
  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Window& default_instance();
  
  void Swap(Window* other);
  
  // implements Message ----------------------------------------------
  
  Window* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Window& from);
  void MergeFrom(const Window& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  
  // optional int32 inner_width = 2;
  inline bool has_inner_width() const;
  inline void clear_inner_width();
  static const int kInnerWidthFieldNumber = 2;
  inline ::google::protobuf::int32 inner_width() const;
  inline void set_inner_width(::google::protobuf::int32 value);
  
  // optional int32 inner_height = 3;
  inline bool has_inner_height() const;
  inline void clear_inner_height();
  static const int kInnerHeightFieldNumber = 3;
  inline ::google::protobuf::int32 inner_height() const;
  inline void set_inner_height(::google::protobuf::int32 value);
  
  // optional int32 outer_width = 4;
  inline bool has_outer_width() const;
  inline void clear_outer_width();
  static const int kOuterWidthFieldNumber = 4;
  inline ::google::protobuf::int32 outer_width() const;
  inline void set_outer_width(::google::protobuf::int32 value);
  
  // optional int32 outer_height = 5;
  inline bool has_outer_height() const;
  inline void clear_outer_height();
  static const int kOuterHeightFieldNumber = 5;
  inline ::google::protobuf::int32 outer_height() const;
  inline void set_outer_height(::google::protobuf::int32 value);
  
  // optional .vdom.Document doc = 6;
  inline bool has_doc() const;
  inline void clear_doc();
  static const int kDocFieldNumber = 6;
  inline const ::vdom::Document& doc() const;
  inline ::vdom::Document* mutable_doc();
  
  // @@protoc_insertion_point(class_scope:vdom.Window)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* location_;
  static const ::std::string _default_location_;
  ::google::protobuf::int32 inner_width_;
  ::google::protobuf::int32 inner_height_;
  ::google::protobuf::int32 outer_width_;
  ::google::protobuf::int32 outer_height_;
  ::vdom::Document* doc_;
  friend void  protobuf_AddDesc_vdom_2eproto();
  friend void protobuf_AssignDesc_vdom_2eproto();
  friend void protobuf_ShutdownFile_vdom_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Window* default_instance_;
};
// -------------------------------------------------------------------

class Document : public ::google::protobuf::Message {
 public:
  Document();
  virtual ~Document();
  
  Document(const Document& from);
  
  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Document& default_instance();
  
  void Swap(Document* other);
  
  // implements Message ----------------------------------------------
  
  Document* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Document& from);
  void MergeFrom(const Document& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // optional string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  
  // optional string keywords = 4;
  inline bool has_keywords() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 4;
  inline const ::std::string& keywords() const;
  inline void set_keywords(const ::std::string& value);
  inline void set_keywords(const char* value);
  inline void set_keywords(const char* value, size_t size);
  inline ::std::string* mutable_keywords();
  
  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  
  // optional .vdom.Node body = 10;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 10;
  inline const ::vdom::Node& body() const;
  inline ::vdom::Node* mutable_body();
  
  // @@protoc_insertion_point(class_scope:vdom.Document)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::std::string* title_;
  static const ::std::string _default_title_;
  ::std::string* keywords_;
  static const ::std::string _default_keywords_;
  ::std::string* description_;
  static const ::std::string _default_description_;
  ::vdom::Node* body_;
  friend void  protobuf_AddDesc_vdom_2eproto();
  friend void protobuf_AssignDesc_vdom_2eproto();
  friend void protobuf_ShutdownFile_vdom_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Document* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();
  
  Node(const Node& from);
  
  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();
  
  void Swap(Node* other);
  
  // implements Message ----------------------------------------------
  
  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Node_Type Type;
  static const Type TEXT = Node_Type_TEXT;
  static const Type ELEMENT = Node_Type_ELEMENT;
  static inline bool Type_IsValid(int value) {
    return Node_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Node_Type_Type_MIN;
  static const Type Type_MAX =
    Node_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Node_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Node_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Node_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Node_Type_Parse(name, value);
  }
  
  typedef Node_RenderType RenderType;
  static const RenderType BLOCK = Node_RenderType_BLOCK;
  static const RenderType INLINE = Node_RenderType_INLINE;
  static const RenderType IMAGE = Node_RenderType_IMAGE;
  static const RenderType VIDEO = Node_RenderType_VIDEO;
  static const RenderType OTHER = Node_RenderType_OTHER;
  static inline bool RenderType_IsValid(int value) {
    return Node_RenderType_IsValid(value);
  }
  static const RenderType RenderType_MIN =
    Node_RenderType_RenderType_MIN;
  static const RenderType RenderType_MAX =
    Node_RenderType_RenderType_MAX;
  static const int RenderType_ARRAYSIZE =
    Node_RenderType_RenderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RenderType_descriptor() {
    return Node_RenderType_descriptor();
  }
  static inline const ::std::string& RenderType_Name(RenderType value) {
    return Node_RenderType_Name(value);
  }
  static inline bool RenderType_Parse(const ::std::string& name,
      RenderType* value) {
    return Node_RenderType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .vdom.Node.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::vdom::Node_Type type() const;
  inline void set_type(::vdom::Node_Type value);
  
  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional int32 w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);
  
  // optional int32 h = 5;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 5;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);
  
  // optional string id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional string tag_name = 6;
  inline bool has_tag_name() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 6;
  inline const ::std::string& tag_name() const;
  inline void set_tag_name(const ::std::string& value);
  inline void set_tag_name(const char* value);
  inline void set_tag_name(const char* value, size_t size);
  inline ::std::string* mutable_tag_name();
  
  // optional string name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string class_name = 9;
  inline bool has_class_name() const;
  inline void clear_class_name();
  static const int kClassNameFieldNumber = 9;
  inline const ::std::string& class_name() const;
  inline void set_class_name(const ::std::string& value);
  inline void set_class_name(const char* value);
  inline void set_class_name(const char* value, size_t size);
  inline ::std::string* mutable_class_name();
  
  // optional string color = 10;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 10;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  
  // optional string background_color = 11;
  inline bool has_background_color() const;
  inline void clear_background_color();
  static const int kBackgroundColorFieldNumber = 11;
  inline const ::std::string& background_color() const;
  inline void set_background_color(const ::std::string& value);
  inline void set_background_color(const char* value);
  inline void set_background_color(const char* value, size_t size);
  inline ::std::string* mutable_background_color();
  
  // optional string target = 12;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 12;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  
  // optional string alt = 13;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 13;
  inline const ::std::string& alt() const;
  inline void set_alt(const ::std::string& value);
  inline void set_alt(const char* value);
  inline void set_alt(const char* value, size_t size);
  inline ::std::string* mutable_alt();
  
  // optional string src = 14;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 14;
  inline const ::std::string& src() const;
  inline void set_src(const ::std::string& value);
  inline void set_src(const char* value);
  inline void set_src(const char* value, size_t size);
  inline ::std::string* mutable_src();
  
  // optional string href = 15;
  inline bool has_href() const;
  inline void clear_href();
  static const int kHrefFieldNumber = 15;
  inline const ::std::string& href() const;
  inline void set_href(const ::std::string& value);
  inline void set_href(const char* value);
  inline void set_href(const char* value, size_t size);
  inline ::std::string* mutable_href();
  
  // optional string value = 16;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 16;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // optional string text = 17;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 17;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  
  // optional .vdom.Node.RenderType render_type = 18 [default = OTHER];
  inline bool has_render_type() const;
  inline void clear_render_type();
  static const int kRenderTypeFieldNumber = 18;
  inline ::vdom::Node_RenderType render_type() const;
  inline void set_render_type(::vdom::Node_RenderType value);
  
  // optional string font_size = 20;
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 20;
  inline const ::std::string& font_size() const;
  inline void set_font_size(const ::std::string& value);
  inline void set_font_size(const char* value);
  inline void set_font_size(const char* value, size_t size);
  inline ::std::string* mutable_font_size();
  
  // optional string font_family = 21;
  inline bool has_font_family() const;
  inline void clear_font_family();
  static const int kFontFamilyFieldNumber = 21;
  inline const ::std::string& font_family() const;
  inline void set_font_family(const ::std::string& value);
  inline void set_font_family(const char* value);
  inline void set_font_family(const char* value, size_t size);
  inline ::std::string* mutable_font_family();
  
  // optional string font_style = 22;
  inline bool has_font_style() const;
  inline void clear_font_style();
  static const int kFontStyleFieldNumber = 22;
  inline const ::std::string& font_style() const;
  inline void set_font_style(const ::std::string& value);
  inline void set_font_style(const char* value);
  inline void set_font_style(const char* value, size_t size);
  inline ::std::string* mutable_font_style();
  
  // optional string font_weight = 23;
  inline bool has_font_weight() const;
  inline void clear_font_weight();
  static const int kFontWeightFieldNumber = 23;
  inline const ::std::string& font_weight() const;
  inline void set_font_weight(const ::std::string& value);
  inline void set_font_weight(const char* value);
  inline void set_font_weight(const char* value, size_t size);
  inline ::std::string* mutable_font_weight();
  
  // repeated .vdom.Node child_nodes = 24;
  inline int child_nodes_size() const;
  inline void clear_child_nodes();
  static const int kChildNodesFieldNumber = 24;
  inline const ::vdom::Node& child_nodes(int index) const;
  inline ::vdom::Node* mutable_child_nodes(int index);
  inline ::vdom::Node* add_child_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::vdom::Node >&
      child_nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::vdom::Node >*
      mutable_child_nodes();

  // @@protoc_insertion_point(class_scope:vdom.Node)
    inline void set_parent_node(Node *parent_node) {
        vd_parent_node = parent_node;
    }

    inline const Node* parent_node() const {
        return vd_parent_node;
    }

    inline void set_child_index(int child_index) {
        vd_child_index = child_index;
    }

    inline int child_index() const {
        return vd_child_index;
    }

    inline const Document* owner_document() const {
        return vd_owner_document;
    }

    inline void set_owner_document(Document* owner_document) {
        vd_owner_document = owner_document;
    }

    inline const Window* owner_window() const {
        return vd_owner_window;
    }

    inline void set_owner_window(Window* owner_window) {
        vd_owner_window = owner_window;
    }

    const Node* first_element_child() const {
        int size = child_nodes_size();
        for (int i = 0; i < size; i++) {
            if (child_nodes(i).type() == ELEMENT)
                return &child_nodes(i);
        }

        return NULL;
    }

    const Node* last_element_child() const {
        int size = child_nodes_size();
        for (int i = size - 1; i >= 0; i--) {
            if (child_nodes(i).type() == ELEMENT)
                return &child_nodes(i);
        }

        return NULL;
    }

    inline const Node* first_child() const {
        if (child_nodes_size() > 0) {
            return &child_nodes(0);
        }
        return NULL;
    }

    inline const Node* last_child() const {
        int size = child_nodes_size();
        if (size > 0) {
            return &child_nodes(size - 1);
        }
        return NULL;
    }

    const Node* previous_element_sibling() const {
        const Node* parent = parent_node();
        int ind = child_index();
        if (ind <= 0 || parent == NULL) {
            return NULL;
        } else {
            for (int i = ind - 1; i >= 0; i--) {
                if (parent->child_nodes(i).type() == ELEMENT)
                    return &parent->child_nodes(i);
            }
            return NULL;
        }
    }

    const Node* next_element_sibling() const {
        const Node* parent = parent_node();
        int ind = child_index();
        int size = parent->child_nodes_size();
        if (ind >= size - 1 || parent == NULL) {
            return NULL;
        } else {
            for (int i = ind + 1; i < size; i++) {
                if (parent->child_nodes(i).type() == ELEMENT)
                    return &parent->child_nodes(i);
            }
            return NULL;
        }

    }

    inline const Node* previous_sibling() const {
        const Node* parent = parent_node();
        int ind = child_index();
        if (ind <= 0 || parent == NULL) {
            return NULL;
        } else {
            return &parent->child_nodes(ind - 1);
        }
    }

    inline const Node* next_sibling() const {
        const Node* parent = parent_node();
        int ind = child_index();
        if (ind > parent->child_nodes_size() || parent == NULL) {
            return NULL;
        } else {
            return &parent->child_nodes(ind + 1);
        }

    }

    inline int numeric_font_size() const {
        const ::std::string &size = font_size();
        if (size.find("px") != ::std::string::npos) {
            return atoi(size.c_str());
        } else {
            return 12;
        }
    }

    inline int numeric_font_weight() const {
        const ::std::string &weight = font_weight();
        if (weight == "bolder") {
            return 900;
        } else if (weight == "bold") {
            return 700;
        } else if (weight == "normal") {
            return 400;
        } else if (weight == "lighter") {
            return 100;
        } else {
            int wi = atoi(weight.c_str());
            if (wi <= 400) {
                return 400;
            } else {
                return wi;
            }
        }
    }

    inline bool has_cached_content() const {
        return vd_has_cached_content;
    }

    const ::std::string& content() const {
        return const_cast<vdom::Node *>(this)->content();
    }

    const ::std::string& content() {
        if (has_cached_content()) {
            return vd_content;
        } else if (type() == TEXT) {
            return text();
        } else {
            vd_content.clear();
            for (int i = 0; i <  child_nodes_size(); i++) {
                vd_content.append(mutable_child_nodes(i)->content());
            }
            vd_has_cached_content = true;
            return vd_content;
        }
    }

    void get_elements_by_tag_name(const ::std::string &tagname, ::std::list<Node*> &node_list) {
        if (type() == ELEMENT) {
            if (this->tag_name() == tagname) {
                node_list.push_back(this);
            }

            int size = child_nodes_size();
            for (int i = 0; i < size; ++i) {
                Node* child = mutable_child_nodes(i);
                if (child->type() == ELEMENT) {
                    child->get_elements_by_tag_name(tagname, node_list);
                }
            }
        }

        //return node_list.size();
    }

    void get_all_texts(::std::list<Node*> &node_list) {
        if (type() == TEXT) {
            node_list.push_back(this);
        } else {
            int size = child_nodes_size();
            for (int i = 0; i < size; ++i) {
                Node* child = mutable_child_nodes(i);
                child->get_all_texts(node_list);
            }
        }
    }

    void get_child_texts(::std::list<Node*> &node_list) {
        if (type() == ELEMENT) {
            int size = child_nodes_size();
            for (int i = 0; i < size; ++i) {
                Node* child = mutable_child_nodes(i);
                if (child->type() == TEXT) {
                    node_list.push_back(child);
                }
            }
        }
    }

    ::std::string markit_selector() {
        return "";
    }

    void get_elements_by_markit_selector(const ::std::string & /*selector*/, ::std::list<Node*> &/*node_list*/) {

        //return node_list.size();
    }

    int rx(Node* base_node) const {
        if (base_node == NULL) {
            return x();
        } else {
            return x() - base_node->x();
        }
    }

    int ry(Node* base_node) const {
        if (base_node == NULL) {
            return y();
        } else {
            return y() - base_node->y();
        }
    }

    int first_text_x() const {
        if (type() == TEXT) {
            return x();
        } else {
            for (int i = 0; i < child_nodes_size(); i++) {
                if (child_nodes(i).type() == TEXT) {
                    return child_nodes(i).x();
                }
            }
            return x();
        }
    }

    bool all_children_inline() const {
        return const_cast<vdom::Node *>(this)->all_children_inline();
    }

    bool all_children_inline() {
        if (!vd_has_all_children_inline) {
            vd_has_all_children_inline = true;

            if (type() == ELEMENT) {
                vd_all_children_inline = true;
                for (int i = 0; i < child_nodes_size(); ++i) {
                    Node *child = mutable_child_nodes(i);
                    if (child->type() == ELEMENT) {
                        if (child->render_type() == BLOCK || child->tag_name() == "BR"
                                || !child->all_children_inline()) {
                            vd_all_children_inline = false;
                            break;
                        }
                    }
                }
            } else {
                vd_all_children_inline = true;
            }
        }

        return vd_all_children_inline;
    }

    void build_vdom_tree(Window* win, Document* doc, Node* parent_node = NULL, int child_index = 0) {
        set_owner_document(doc);
        set_owner_window(win);
        set_parent_node(parent_node);
        set_child_index(child_index);
        vd_has_cached_content = false;
        vd_has_all_children_inline = false;
        vd_has_normalized_content = false;

        for (int i = 0; i < child_nodes_size(); i++) {
            Node *child = mutable_child_nodes(i);
            child->build_vdom_tree(win, doc, this, i);
        }
    }

    inline const ::std::string& repeat_sig() const {
        return vd_repeat_sig;
    }

    void build_repeat_sig() {
        vd_repeat_sig.clear();
        if (type() == ELEMENT) {
            bool is_good_node = true;
            const std::string &tag = tag_name();
            if (tag == "FONT" || tag == "FORM") {
                is_good_node = false;
            }

            if (is_good_node) {
                vd_repeat_sig.append("#");
                vd_repeat_sig.append(tag_name());
            }
            for (int i = 0; i < child_nodes_size(); i++) {
                Node *child = mutable_child_nodes(i);
                if (child->type() == ELEMENT) {
                    //vd_repeat_sig.append("#");
                    //vd_repeat_sig.append(child->tag_name());
                    child->build_repeat_sig();
                    vd_repeat_sig.append(child->repeat_sig());
                    //vd_repeat_sig.append("-");
                    //vd_repeat_sig.append(child->tag_name());
                }
            }
            if (is_good_node) {
                vd_repeat_sig.append("-");
                vd_repeat_sig.append(tag_name());
            }
        } else {
            vd_repeat_sig = "";
        }
    }

    inline const ::std::string& normalized_content() {
        if (!vd_has_normalized_content) {
            normalize_text(content(), vd_normalized_content);
            vd_has_normalized_content = true;
        }
        return vd_normalized_content;
    }


    void normalize_text(const std::string &raw, std::string &normalized) {
        bool start_content = false;
        bool has_space = false;

        const char *p = raw.c_str();
        int len = raw.size();
        normalized.clear();
        normalized.reserve(len);
        for (int i = 0; i < len; i++) {
            unsigned char c = *(p+i);
            if (isspace(c)) {
                has_space = true;
            } else if (c == (unsigned char)'\xc2' && i < len - 1 && (*(p+i+1)) == '\xa0') {
                has_space = true;
                ++i;
            } else if (c == (unsigned char)'\xe3' && i < len - 2 && (*(p+i+1)) == '\x80' && (*(p+i+2)) == '\x80') {
                has_space = true;
                i += 2;
            } else if ((int) c <= 20) {
                // skip
                //has_space = true;
            } else {
                if (start_content && has_space) {
                    normalized.append(" ");
                }

                if (!start_content) {
                    start_content = true;
                }

                has_space = false;
                normalized.append(1, c);
            }
        }
    }

    private:
        Node *vd_parent_node;
        int vd_child_index;
        Document *vd_owner_document;
        Window *vd_owner_window;
        bool vd_has_cached_content;
        ::std::string vd_content;
        bool vd_has_all_children_inline;
        bool vd_all_children_inline;
        std::string vd_repeat_sig;
        bool vd_has_normalized_content;
        std::string vd_normalized_content;



  // @@protoc_insertion_point(class_scope:vdom.Node)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::std::string* tag_name_;
  static const ::std::string _default_tag_name_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* class_name_;
  static const ::std::string _default_class_name_;
  ::std::string* color_;
  static const ::std::string _default_color_;
  ::std::string* background_color_;
  static const ::std::string _default_background_color_;
  ::std::string* target_;
  static const ::std::string _default_target_;
  ::std::string* alt_;
  static const ::std::string _default_alt_;
  ::std::string* src_;
  static const ::std::string _default_src_;
  ::std::string* href_;
  static const ::std::string _default_href_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::std::string* text_;
  static const ::std::string _default_text_;
  int render_type_;
  ::std::string* font_size_;
  static const ::std::string _default_font_size_;
  ::std::string* font_family_;
  static const ::std::string _default_font_family_;
  ::std::string* font_style_;
  static const ::std::string _default_font_style_;
  ::std::string* font_weight_;
  static const ::std::string _default_font_weight_;
  ::google::protobuf::RepeatedPtrField< ::vdom::Node > child_nodes_;
  friend void  protobuf_AddDesc_vdom_2eproto();
  friend void protobuf_AssignDesc_vdom_2eproto();
  friend void protobuf_ShutdownFile_vdom_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// ===================================================================


// ===================================================================

// Window

// required string location = 1;
inline bool Window::has_location() const {
  return _has_bit(0);
}
inline void Window::clear_location() {
  if (location_ != &_default_location_) {
    location_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Window::location() const {
  return *location_;
}
inline void Window::set_location(const ::std::string& value) {
  _set_bit(0);
  if (location_ == &_default_location_) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Window::set_location(const char* value) {
  _set_bit(0);
  if (location_ == &_default_location_) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Window::set_location(const char* value, size_t size) {
  _set_bit(0);
  if (location_ == &_default_location_) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Window::mutable_location() {
  _set_bit(0);
  if (location_ == &_default_location_) {
    location_ = new ::std::string;
  }
  return location_;
}

// optional int32 inner_width = 2;
inline bool Window::has_inner_width() const {
  return _has_bit(1);
}
inline void Window::clear_inner_width() {
  inner_width_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Window::inner_width() const {
  return inner_width_;
}
inline void Window::set_inner_width(::google::protobuf::int32 value) {
  _set_bit(1);
  inner_width_ = value;
}

// optional int32 inner_height = 3;
inline bool Window::has_inner_height() const {
  return _has_bit(2);
}
inline void Window::clear_inner_height() {
  inner_height_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Window::inner_height() const {
  return inner_height_;
}
inline void Window::set_inner_height(::google::protobuf::int32 value) {
  _set_bit(2);
  inner_height_ = value;
}

// optional int32 outer_width = 4;
inline bool Window::has_outer_width() const {
  return _has_bit(3);
}
inline void Window::clear_outer_width() {
  outer_width_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Window::outer_width() const {
  return outer_width_;
}
inline void Window::set_outer_width(::google::protobuf::int32 value) {
  _set_bit(3);
  outer_width_ = value;
}

// optional int32 outer_height = 5;
inline bool Window::has_outer_height() const {
  return _has_bit(4);
}
inline void Window::clear_outer_height() {
  outer_height_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Window::outer_height() const {
  return outer_height_;
}
inline void Window::set_outer_height(::google::protobuf::int32 value) {
  _set_bit(4);
  outer_height_ = value;
}

// optional .vdom.Document doc = 6;
inline bool Window::has_doc() const {
  return _has_bit(5);
}
inline void Window::clear_doc() {
  if (doc_ != NULL) doc_->::vdom::Document::Clear();
  _clear_bit(5);
}
inline const ::vdom::Document& Window::doc() const {
  return doc_ != NULL ? *doc_ : *default_instance_->doc_;
}
inline ::vdom::Document* Window::mutable_doc() {
  _set_bit(5);
  if (doc_ == NULL) doc_ = new ::vdom::Document;
  return doc_;
}

// -------------------------------------------------------------------

// Document

// optional int32 width = 1;
inline bool Document::has_width() const {
  return _has_bit(0);
}
inline void Document::clear_width() {
  width_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Document::width() const {
  return width_;
}
inline void Document::set_width(::google::protobuf::int32 value) {
  _set_bit(0);
  width_ = value;
}

// optional int32 height = 2;
inline bool Document::has_height() const {
  return _has_bit(1);
}
inline void Document::clear_height() {
  height_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Document::height() const {
  return height_;
}
inline void Document::set_height(::google::protobuf::int32 value) {
  _set_bit(1);
  height_ = value;
}

// optional string title = 3;
inline bool Document::has_title() const {
  return _has_bit(2);
}
inline void Document::clear_title() {
  if (title_ != &_default_title_) {
    title_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Document::title() const {
  return *title_;
}
inline void Document::set_title(const ::std::string& value) {
  _set_bit(2);
  if (title_ == &_default_title_) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Document::set_title(const char* value) {
  _set_bit(2);
  if (title_ == &_default_title_) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Document::set_title(const char* value, size_t size) {
  _set_bit(2);
  if (title_ == &_default_title_) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_title() {
  _set_bit(2);
  if (title_ == &_default_title_) {
    title_ = new ::std::string;
  }
  return title_;
}

// optional string keywords = 4;
inline bool Document::has_keywords() const {
  return _has_bit(3);
}
inline void Document::clear_keywords() {
  if (keywords_ != &_default_keywords_) {
    keywords_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Document::keywords() const {
  return *keywords_;
}
inline void Document::set_keywords(const ::std::string& value) {
  _set_bit(3);
  if (keywords_ == &_default_keywords_) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(value);
}
inline void Document::set_keywords(const char* value) {
  _set_bit(3);
  if (keywords_ == &_default_keywords_) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(value);
}
inline void Document::set_keywords(const char* value, size_t size) {
  _set_bit(3);
  if (keywords_ == &_default_keywords_) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_keywords() {
  _set_bit(3);
  if (keywords_ == &_default_keywords_) {
    keywords_ = new ::std::string;
  }
  return keywords_;
}

// optional string description = 5;
inline bool Document::has_description() const {
  return _has_bit(4);
}
inline void Document::clear_description() {
  if (description_ != &_default_description_) {
    description_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Document::description() const {
  return *description_;
}
inline void Document::set_description(const ::std::string& value) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Document::set_description(const char* value) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Document::set_description(const char* value, size_t size) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_description() {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  return description_;
}

// optional .vdom.Node body = 10;
inline bool Document::has_body() const {
  return _has_bit(5);
}
inline void Document::clear_body() {
  if (body_ != NULL) body_->::vdom::Node::Clear();
  _clear_bit(5);
}
inline const ::vdom::Node& Document::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::vdom::Node* Document::mutable_body() {
  _set_bit(5);
  if (body_ == NULL) body_ = new ::vdom::Node;
  return body_;
}

// -------------------------------------------------------------------

// Node

// required .vdom.Node.Type type = 1;
inline bool Node::has_type() const {
  return _has_bit(0);
}
inline void Node::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::vdom::Node_Type Node::type() const {
  return static_cast< ::vdom::Node_Type >(type_);
}
inline void Node::set_type(::vdom::Node_Type value) {
  GOOGLE_DCHECK(::vdom::Node_Type_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional int32 x = 2;
inline bool Node::has_x() const {
  return _has_bit(1);
}
inline void Node::clear_x() {
  x_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Node::x() const {
  return x_;
}
inline void Node::set_x(::google::protobuf::int32 value) {
  _set_bit(1);
  x_ = value;
}

// optional int32 y = 3;
inline bool Node::has_y() const {
  return _has_bit(2);
}
inline void Node::clear_y() {
  y_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Node::y() const {
  return y_;
}
inline void Node::set_y(::google::protobuf::int32 value) {
  _set_bit(2);
  y_ = value;
}

// optional int32 w = 4;
inline bool Node::has_w() const {
  return _has_bit(3);
}
inline void Node::clear_w() {
  w_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Node::w() const {
  return w_;
}
inline void Node::set_w(::google::protobuf::int32 value) {
  _set_bit(3);
  w_ = value;
}

// optional int32 h = 5;
inline bool Node::has_h() const {
  return _has_bit(4);
}
inline void Node::clear_h() {
  h_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Node::h() const {
  return h_;
}
inline void Node::set_h(::google::protobuf::int32 value) {
  _set_bit(4);
  h_ = value;
}

// optional string id = 7;
inline bool Node::has_id() const {
  return _has_bit(5);
}
inline void Node::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Node::id() const {
  return *id_;
}
inline void Node::set_id(const ::std::string& value) {
  _set_bit(5);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Node::set_id(const char* value) {
  _set_bit(5);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Node::set_id(const char* value, size_t size) {
  _set_bit(5);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_id() {
  _set_bit(5);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional string tag_name = 6;
inline bool Node::has_tag_name() const {
  return _has_bit(6);
}
inline void Node::clear_tag_name() {
  if (tag_name_ != &_default_tag_name_) {
    tag_name_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& Node::tag_name() const {
  return *tag_name_;
}
inline void Node::set_tag_name(const ::std::string& value) {
  _set_bit(6);
  if (tag_name_ == &_default_tag_name_) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
}
inline void Node::set_tag_name(const char* value) {
  _set_bit(6);
  if (tag_name_ == &_default_tag_name_) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
}
inline void Node::set_tag_name(const char* value, size_t size) {
  _set_bit(6);
  if (tag_name_ == &_default_tag_name_) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_tag_name() {
  _set_bit(6);
  if (tag_name_ == &_default_tag_name_) {
    tag_name_ = new ::std::string;
  }
  return tag_name_;
}

// optional string name = 8;
inline bool Node::has_name() const {
  return _has_bit(7);
}
inline void Node::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& Node::name() const {
  return *name_;
}
inline void Node::set_name(const ::std::string& value) {
  _set_bit(7);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Node::set_name(const char* value) {
  _set_bit(7);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Node::set_name(const char* value, size_t size) {
  _set_bit(7);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_name() {
  _set_bit(7);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string class_name = 9;
inline bool Node::has_class_name() const {
  return _has_bit(8);
}
inline void Node::clear_class_name() {
  if (class_name_ != &_default_class_name_) {
    class_name_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& Node::class_name() const {
  return *class_name_;
}
inline void Node::set_class_name(const ::std::string& value) {
  _set_bit(8);
  if (class_name_ == &_default_class_name_) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void Node::set_class_name(const char* value) {
  _set_bit(8);
  if (class_name_ == &_default_class_name_) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void Node::set_class_name(const char* value, size_t size) {
  _set_bit(8);
  if (class_name_ == &_default_class_name_) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_class_name() {
  _set_bit(8);
  if (class_name_ == &_default_class_name_) {
    class_name_ = new ::std::string;
  }
  return class_name_;
}

// optional string color = 10;
inline bool Node::has_color() const {
  return _has_bit(9);
}
inline void Node::clear_color() {
  if (color_ != &_default_color_) {
    color_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& Node::color() const {
  return *color_;
}
inline void Node::set_color(const ::std::string& value) {
  _set_bit(9);
  if (color_ == &_default_color_) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void Node::set_color(const char* value) {
  _set_bit(9);
  if (color_ == &_default_color_) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void Node::set_color(const char* value, size_t size) {
  _set_bit(9);
  if (color_ == &_default_color_) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_color() {
  _set_bit(9);
  if (color_ == &_default_color_) {
    color_ = new ::std::string;
  }
  return color_;
}

// optional string background_color = 11;
inline bool Node::has_background_color() const {
  return _has_bit(10);
}
inline void Node::clear_background_color() {
  if (background_color_ != &_default_background_color_) {
    background_color_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& Node::background_color() const {
  return *background_color_;
}
inline void Node::set_background_color(const ::std::string& value) {
  _set_bit(10);
  if (background_color_ == &_default_background_color_) {
    background_color_ = new ::std::string;
  }
  background_color_->assign(value);
}
inline void Node::set_background_color(const char* value) {
  _set_bit(10);
  if (background_color_ == &_default_background_color_) {
    background_color_ = new ::std::string;
  }
  background_color_->assign(value);
}
inline void Node::set_background_color(const char* value, size_t size) {
  _set_bit(10);
  if (background_color_ == &_default_background_color_) {
    background_color_ = new ::std::string;
  }
  background_color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_background_color() {
  _set_bit(10);
  if (background_color_ == &_default_background_color_) {
    background_color_ = new ::std::string;
  }
  return background_color_;
}

// optional string target = 12;
inline bool Node::has_target() const {
  return _has_bit(11);
}
inline void Node::clear_target() {
  if (target_ != &_default_target_) {
    target_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& Node::target() const {
  return *target_;
}
inline void Node::set_target(const ::std::string& value) {
  _set_bit(11);
  if (target_ == &_default_target_) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void Node::set_target(const char* value) {
  _set_bit(11);
  if (target_ == &_default_target_) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void Node::set_target(const char* value, size_t size) {
  _set_bit(11);
  if (target_ == &_default_target_) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_target() {
  _set_bit(11);
  if (target_ == &_default_target_) {
    target_ = new ::std::string;
  }
  return target_;
}

// optional string alt = 13;
inline bool Node::has_alt() const {
  return _has_bit(12);
}
inline void Node::clear_alt() {
  if (alt_ != &_default_alt_) {
    alt_->clear();
  }
  _clear_bit(12);
}
inline const ::std::string& Node::alt() const {
  return *alt_;
}
inline void Node::set_alt(const ::std::string& value) {
  _set_bit(12);
  if (alt_ == &_default_alt_) {
    alt_ = new ::std::string;
  }
  alt_->assign(value);
}
inline void Node::set_alt(const char* value) {
  _set_bit(12);
  if (alt_ == &_default_alt_) {
    alt_ = new ::std::string;
  }
  alt_->assign(value);
}
inline void Node::set_alt(const char* value, size_t size) {
  _set_bit(12);
  if (alt_ == &_default_alt_) {
    alt_ = new ::std::string;
  }
  alt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_alt() {
  _set_bit(12);
  if (alt_ == &_default_alt_) {
    alt_ = new ::std::string;
  }
  return alt_;
}

// optional string src = 14;
inline bool Node::has_src() const {
  return _has_bit(13);
}
inline void Node::clear_src() {
  if (src_ != &_default_src_) {
    src_->clear();
  }
  _clear_bit(13);
}
inline const ::std::string& Node::src() const {
  return *src_;
}
inline void Node::set_src(const ::std::string& value) {
  _set_bit(13);
  if (src_ == &_default_src_) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void Node::set_src(const char* value) {
  _set_bit(13);
  if (src_ == &_default_src_) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void Node::set_src(const char* value, size_t size) {
  _set_bit(13);
  if (src_ == &_default_src_) {
    src_ = new ::std::string;
  }
  src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_src() {
  _set_bit(13);
  if (src_ == &_default_src_) {
    src_ = new ::std::string;
  }
  return src_;
}

// optional string href = 15;
inline bool Node::has_href() const {
  return _has_bit(14);
}
inline void Node::clear_href() {
  if (href_ != &_default_href_) {
    href_->clear();
  }
  _clear_bit(14);
}
inline const ::std::string& Node::href() const {
  return *href_;
}
inline void Node::set_href(const ::std::string& value) {
  _set_bit(14);
  if (href_ == &_default_href_) {
    href_ = new ::std::string;
  }
  href_->assign(value);
}
inline void Node::set_href(const char* value) {
  _set_bit(14);
  if (href_ == &_default_href_) {
    href_ = new ::std::string;
  }
  href_->assign(value);
}
inline void Node::set_href(const char* value, size_t size) {
  _set_bit(14);
  if (href_ == &_default_href_) {
    href_ = new ::std::string;
  }
  href_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_href() {
  _set_bit(14);
  if (href_ == &_default_href_) {
    href_ = new ::std::string;
  }
  return href_;
}

// optional string value = 16;
inline bool Node::has_value() const {
  return _has_bit(15);
}
inline void Node::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(15);
}
inline const ::std::string& Node::value() const {
  return *value_;
}
inline void Node::set_value(const ::std::string& value) {
  _set_bit(15);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Node::set_value(const char* value) {
  _set_bit(15);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Node::set_value(const char* value, size_t size) {
  _set_bit(15);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_value() {
  _set_bit(15);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional string text = 17;
inline bool Node::has_text() const {
  return _has_bit(16);
}
inline void Node::clear_text() {
  if (text_ != &_default_text_) {
    text_->clear();
  }
  _clear_bit(16);
}
inline const ::std::string& Node::text() const {
  return *text_;
}
inline void Node::set_text(const ::std::string& value) {
  _set_bit(16);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Node::set_text(const char* value) {
  _set_bit(16);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Node::set_text(const char* value, size_t size) {
  _set_bit(16);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_text() {
  _set_bit(16);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  return text_;
}

// optional .vdom.Node.RenderType render_type = 18 [default = OTHER];
inline bool Node::has_render_type() const {
  return _has_bit(17);
}
inline void Node::clear_render_type() {
  render_type_ = 10;
  _clear_bit(17);
}
inline ::vdom::Node_RenderType Node::render_type() const {
  return static_cast< ::vdom::Node_RenderType >(render_type_);
}
inline void Node::set_render_type(::vdom::Node_RenderType value) {
  GOOGLE_DCHECK(::vdom::Node_RenderType_IsValid(value));
  _set_bit(17);
  render_type_ = value;
}

// optional string font_size = 20;
inline bool Node::has_font_size() const {
  return _has_bit(18);
}
inline void Node::clear_font_size() {
  if (font_size_ != &_default_font_size_) {
    font_size_->clear();
  }
  _clear_bit(18);
}
inline const ::std::string& Node::font_size() const {
  return *font_size_;
}
inline void Node::set_font_size(const ::std::string& value) {
  _set_bit(18);
  if (font_size_ == &_default_font_size_) {
    font_size_ = new ::std::string;
  }
  font_size_->assign(value);
}
inline void Node::set_font_size(const char* value) {
  _set_bit(18);
  if (font_size_ == &_default_font_size_) {
    font_size_ = new ::std::string;
  }
  font_size_->assign(value);
}
inline void Node::set_font_size(const char* value, size_t size) {
  _set_bit(18);
  if (font_size_ == &_default_font_size_) {
    font_size_ = new ::std::string;
  }
  font_size_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_font_size() {
  _set_bit(18);
  if (font_size_ == &_default_font_size_) {
    font_size_ = new ::std::string;
  }
  return font_size_;
}

// optional string font_family = 21;
inline bool Node::has_font_family() const {
  return _has_bit(19);
}
inline void Node::clear_font_family() {
  if (font_family_ != &_default_font_family_) {
    font_family_->clear();
  }
  _clear_bit(19);
}
inline const ::std::string& Node::font_family() const {
  return *font_family_;
}
inline void Node::set_font_family(const ::std::string& value) {
  _set_bit(19);
  if (font_family_ == &_default_font_family_) {
    font_family_ = new ::std::string;
  }
  font_family_->assign(value);
}
inline void Node::set_font_family(const char* value) {
  _set_bit(19);
  if (font_family_ == &_default_font_family_) {
    font_family_ = new ::std::string;
  }
  font_family_->assign(value);
}
inline void Node::set_font_family(const char* value, size_t size) {
  _set_bit(19);
  if (font_family_ == &_default_font_family_) {
    font_family_ = new ::std::string;
  }
  font_family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_font_family() {
  _set_bit(19);
  if (font_family_ == &_default_font_family_) {
    font_family_ = new ::std::string;
  }
  return font_family_;
}

// optional string font_style = 22;
inline bool Node::has_font_style() const {
  return _has_bit(20);
}
inline void Node::clear_font_style() {
  if (font_style_ != &_default_font_style_) {
    font_style_->clear();
  }
  _clear_bit(20);
}
inline const ::std::string& Node::font_style() const {
  return *font_style_;
}
inline void Node::set_font_style(const ::std::string& value) {
  _set_bit(20);
  if (font_style_ == &_default_font_style_) {
    font_style_ = new ::std::string;
  }
  font_style_->assign(value);
}
inline void Node::set_font_style(const char* value) {
  _set_bit(20);
  if (font_style_ == &_default_font_style_) {
    font_style_ = new ::std::string;
  }
  font_style_->assign(value);
}
inline void Node::set_font_style(const char* value, size_t size) {
  _set_bit(20);
  if (font_style_ == &_default_font_style_) {
    font_style_ = new ::std::string;
  }
  font_style_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_font_style() {
  _set_bit(20);
  if (font_style_ == &_default_font_style_) {
    font_style_ = new ::std::string;
  }
  return font_style_;
}

// optional string font_weight = 23;
inline bool Node::has_font_weight() const {
  return _has_bit(21);
}
inline void Node::clear_font_weight() {
  if (font_weight_ != &_default_font_weight_) {
    font_weight_->clear();
  }
  _clear_bit(21);
}
inline const ::std::string& Node::font_weight() const {
  return *font_weight_;
}
inline void Node::set_font_weight(const ::std::string& value) {
  _set_bit(21);
  if (font_weight_ == &_default_font_weight_) {
    font_weight_ = new ::std::string;
  }
  font_weight_->assign(value);
}
inline void Node::set_font_weight(const char* value) {
  _set_bit(21);
  if (font_weight_ == &_default_font_weight_) {
    font_weight_ = new ::std::string;
  }
  font_weight_->assign(value);
}
inline void Node::set_font_weight(const char* value, size_t size) {
  _set_bit(21);
  if (font_weight_ == &_default_font_weight_) {
    font_weight_ = new ::std::string;
  }
  font_weight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_font_weight() {
  _set_bit(21);
  if (font_weight_ == &_default_font_weight_) {
    font_weight_ = new ::std::string;
  }
  return font_weight_;
}

// repeated .vdom.Node child_nodes = 24;
inline int Node::child_nodes_size() const {
  return child_nodes_.size();
}
inline void Node::clear_child_nodes() {
  child_nodes_.Clear();
}
inline const ::vdom::Node& Node::child_nodes(int index) const {
  return child_nodes_.Get(index);
}
inline ::vdom::Node* Node::mutable_child_nodes(int index) {
  return child_nodes_.Mutable(index);
}
inline ::vdom::Node* Node::add_child_nodes() {
  return child_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vdom::Node >&
Node::child_nodes() const {
  return child_nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::vdom::Node >*
Node::mutable_child_nodes() {
  return &child_nodes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vdom

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vdom::Node_Type>() {
  return ::vdom::Node_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vdom::Node_RenderType>() {
  return ::vdom::Node_RenderType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vdom_2eproto__INCLUDED
